#!/bin/bash

version="0.0.1"
script=${0##*/}
usage="\
Module Git (v$version)

Global Commands:
  $script [options] <command>
-------------------------------
  init                    initialize .modgit folder
  list                    list all modules that are currently installed
  update-all              update all modules that are currently installed
  -h                      this help
  -v                      display the modgit script's version

Module Commands:
  $script [options] <command> <module> [<src>] -- [<git options>]
-------------------------------------------------------------------
  clone <module> <src>    clone a git repository
  update <module> [<src>] update module with optional new repository
  remove <module>         remove module
  [<git options>]         specify additional parameters to git clone
  -i                      include filter: -i app/ -i README ...
  -e                      exclude filter: -e file -e lib/tests ...
"

dry_run=0
includes=''
excludes=''

add_include ()
{
  if [ -z $includes ]; then
    includes="$1"
  else
    includes="$includes\n$1"
  fi
}

add_exclude ()
{
  if [ -z $excludes ]; then
    excludes="$1"
  else
    excludes="$excludes\n$1"
  fi
}

# Handle options
while getopts ":nvhi:e:" opt; do
  case $opt in
    h)
      echo -e "$usage"
      exit 0
      ;;
    v)
      echo "Module Git version: $version"
      exit 0
      ;;
    n)
      dry_run=1
      shift $((OPTIND-1)); OPTIND=1
      ;;
    i)
      add_include "$OPTARG"
      shift $((OPTIND-1)); OPTIND=1
      ;;
    e)
      add_exclude "$OPTARG"
      shift $((OPTIND-1)); OPTIND=1
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      exit 1
      ;;
    :)
      echo "Option -$OPTARG requires an argument." >&2
      exit 1
      ;;
  esac
done

# Echo in bold
echo_b ()
{
  if [ "$1" = "-e" ]; then
    echo -e "$(tput bold)$2$(tput sgr0)"
  else
    echo "$(tput bold)$1$(tput sgr0)"
  fi
}

# Initializes .modgit folder in root dir then quit
if [ "$1" = "init" ]; then
  mkdir .modgit || { echo_b "Could not create .modgit directory" && exit 1; }
  echo_b "Initialized Module Git at $(pwd)"
  exit 0
fi

# Checks if module dir exists or quit
require_module_dir ()
{
  if ! [ -d "$modgit_dir/$1" ]; then
    echo_b "ERROR: $1 does not exist.";
    exit 1
  fi
  return 0
}

# Removes module files from root dir
delete_files ()
{
  local module_dir=$1
  while read line; do
    if ! [ -z $line ] && [ -f "$root/$line" ]; then
      rm "$root/$line" 2>/dev/null
      prev_dir=''
      dir=$(dirname $line)
      while [ "$dir" != "$prev_dir" ]; do
        prev_dir=$dir
        test_dir="$root/$dir"
        if ! [ "$(ls -A $test_dir)" ]; then
          rmdir $test_dir
        fi
        dir=${dir%/*}
      done
    fi
  done < <(tail +2 "$module_dir/source.modgit")
  return 0
}

# Synchronizes files from module dir to root dir then removes source files
move_files ()
{
  local module_dir=$1
  cd "$module_dir"
  rsync -a --exclude "*.modgit" --exclude ".gitignore" "." "$root"
  find . -not -name "*.modgit" -exec rm -rf {} \; 2>/dev/null
  return 0
}

# Creates module dir, clones git repo then apply include/exclude filters
create_module ()
{
  local repo=$1
  local dir=$2
  cd "$modgit_dir"
  git clone --recursive "$repo" "$dir"
  if [ -d "$dir" ] &&
    cd "$dir" &&
    rm -rf .git &&
    echo "$repo" > source.modgit &&
    find . -type f -not -name "*.modgit" | sed 's/^\.\///' >> source.modgit
    touch includes.modgit
    touch excludes.modgit
    if ! [ -z $includes ]; then
      echo -e $includes > includes.modgit
    fi
    if ! [ -z $excludes ]; then
      echo -e $excludes > excludes.modgit
    fi

    if [ -s includes.modgit ] || [ -s excludes.modgit ]; then
      while read file; do
        if [ -s includes.modgit ]; then delete=1; else delete=0; fi

        # Include filters
        while read filter; do
          filter=$(echo $filter | cut -d: -f1)
          if [[ $file =~ ^$filter ]]; then
            delete=0
            break
          fi
        done < <(tail includes.modgit)

        if [ $delete -eq 0 ]; then
          # Exclude filters
          while read filter; do
            if [[ $file =~ ^$filter ]]; then
              delete=1
              break
            fi
          done < <(tail excludes.modgit)
        fi

        if [ $delete -eq 1 ]; then
          rm -f $file
        fi
      done < <(tail +2 source.modgit)
      find . -depth -type d -empty -exec rmdir {} \; 2> /dev/null
    fi
  then
    return 0
  else
    return 1
  fi
}

# Updates a module, calls create_module with original git repo or
# clone a another one with optional include/exclude filters
update_module ()
{
  local module=$1
  local module_dir="$modgit_dir/$module"
  local repo=''

  if [ -z $includes ]; then
    while read line; do
      add_include $line
    done < <(tail "$module_dir/includes.modgit")
  fi
  
  if [ -z $excludes ]; then
    while read line; do
      add_exclude $line
    done < <(tail "$module_dir/excludes.modgit")
  fi
  
  if [ $2 ]; then repo=$2; else repo=$(head -1 "$module_dir/source.modgit"); fi
  
  if require_module_dir "$module" &&
    rm -rf "$modgit_dir/tmp" 2>/dev/null
    create_module "$repo" "$modgit_dir/tmp" &&
    delete_files "$module_dir" &&
    rm "$module_dir/source.modgit" &&
    cp -pRP "$modgit_dir/tmp/" "$module_dir" &&
    rm -rf "$modgit_dir/tmp" &&
    move_files "$module_dir";
  then
    return 0
  else
    rm -rf "$modgit_dir/tmp" 2>/dev/null
    return 1
  fi
}

# Try to find .modgit dir
_pwd=$(pwd -P)
root=$_pwd
if ! [ -d $root/.modgit ]; then
  echo_b "-e" "Module Git directory not found.\nRun \"$script init\" in the root of your project."
  exit 1
fi

modgit_dir=$root/.modgit # path to .modgit

# list command
if [ "$1" = "list" ]; then
  if [ -n "$2" ]; then echo "Too many arguments for list command."; exit 1; fi
  while read -d $'\n' module; do
    test -d "$modgit_dir/$module" || continue;
    require_module_dir "$module" && echo "$module"
  done < <(ls -1 "$modgit_dir")
  exit 0

# update-all command
elif [ "$1" = "update-all" ]; then
  if [ -n "$2" ]; then echo "Too many arguments for update-all command."; exit 1; fi
  update_errors=0
  updated=''
  while read -d $'\n' module; do
    test -d "$modgit_dir/$module" || continue;
    echo "Updating $module..."
    if ! update_module "$module"; then
      echo_b "-e" "Error occurred while updating '$module'.\n"
      update_errors=$((update_errors+1))
    fi
  done < <(ls -1 "$modgit_dir")
  echo_b "Updated all modules with $update_errors update errors."
  exit 0
fi

#############################################
# Handle all other module-specific commands #
#############################################

REGEX_ACTION='(clone|update|remove|tmp)'

# Action is first argument
action=''
if [[ "$1" =~ $REGEX_ACTION ]]; then
  action=$1; shift
fi

# If no module discovered or valid module is specified on command line
if [ -z "$module" ] || [ -n "$1" -a -d "$modgit_dir/$1" ]; then
  module=$1; shift               # module name is first argument
fi

[ -z "$module" ] && { echo "Not enough arguments (no module specified)"; exit 1; }
[ -z "$action" ] && { echo "Not enough arguments (no action specified)"; exit 1; }

cd "$_pwd"                       # restore old root
module_dir="$modgit_dir/$module" # working copy directory for module

# Handle module action
case "$action" in

  clone)

    if [[ "$module" =~ $REGEX_ACTION ]]; then
      echo_b "You cannot $action a module with a name matching $REGEX_ACTION."; exit 1
    fi

    if [ "$action" = "clone" ] && [ -d "$module_dir" ]; then
      echo_b "A module with this name has already been cloned."; exit 1
    fi

    repo=$1; shift
    create_module "$repo" "$module" && success=1

    if [ $success -eq 1 ]; then
      if require_module_dir "$module" &&
        move_files "$module_dir";
      then
        echo_b "Clone of $module complete."
      fi
    else
      if [ -d "$module_dir" ]; then rm -rf "$module_dir"; fi
      echo_b "Error cloning $module, operation cancelled."
    fi
    ;;

  update)

    if update_module "$module" "$1"
    then
      echo_b "Update of $module complete."
    else
      echo_b "Error updating $module, operation cancelled."
    fi
    ;;

  remove)
  
    if require_module_dir "$module" &&
      delete_files "$module_dir" &&
      rm -rf "$module_dir";
    then
      echo_b "Removal of $module complete."
    else
      echo_b "Error removing $module, operation cancelled."
    fi
    ;;

  *)
    echo -e "$usage"
    echo_b "Invalid action: $action";
    exit;

esac
